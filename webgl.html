<!DOCTYPE html>

<head>
  <title>WebGL</title>
</head>

<body>
  <canvas id="canvas" style="border: none;" width="800" height="800">Canvas not supported</canvas>
  <script src="http://www.kamaron.me/tutorial-live/webgl/02-rotating-cube/gl-matrix.js"></script>
  <script id="shader-vs" type="x-shader/x-vertex">
    precision mediump float;

    attribute vec3 vertPosition;
    varying vec3 fragColor;
    uniform mat4 mWorld;
    uniform mat4 mView;
    uniform mat4 mProj;

    void main()
    {
      fragColor = vec3(0.0, 0.0, 1.0);
      gl_Position = mProj * mView * mWorld * vec4(vertPosition, 1.0);
    }
  </script>
  <script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec3 fragColor;
    void main()
    {
      gl_FragColor = vec4(fragColor, 1.0);
    }
  </script>
  <script>
    let gl, program, buffer;

    main();


    function main(){
      initGL();
      initProgram();
      initShaders();
      linkProgram();
      initBuffer();
      initAttrib();
      initUniform();

      render();
    }


    function initGL(){
      let canvas = document.getElementById('canvas');
      gl = canvas.getContext('webgl');
      if (!gl) {
          console.warn('webgl not supported, trying experimental-webgl')
          let gl = canvas.getContext('experimental-webgl');
          if (!gl) {
              console.error('your browser does not support webgl');
              return;
          }
      }

      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      gl.enable(gl.DEPTH_TEST);
      gl.enable(gl.CULL_FACE);
      gl.frontFace(gl.CCW);
      gl.cullFace(gl.BACK);
    }
    function initProgram(){
      program = gl.createProgram();
    }
    function initShaders(){
      let vertexShaderText = document.getElementById('shader-vs').text;
      let fragmentShaderText = document.getElementById('shader-fs').text;

      let vertexShader = gl.createShader(gl.VERTEX_SHADER);
      let fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

      gl.shaderSource(vertexShader, vertexShaderText);
      gl.shaderSource(fragmentShader, fragmentShaderText);

      gl.compileShader(vertexShader);
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      	console.error(`ERROR compiling vertex shader! \n ${gl.getShaderInfoLog(vertexShader)}`);
      }
      gl.compileShader(fragmentShader);
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      	console.error(`ERROR compiling fragment shader! \n ${gl.getShaderInfoLog(fragmentShader)}`);
      }

      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
    }
    function linkProgram(){
      gl.linkProgram(program);

      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('ERROR linking program!', gl.getProgramInfoLog(program));
      }

      gl.validateProgram(program);
      if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
        console.error('ERROR validating program!', gl.getProgramInfoLog(program));
        return;
      }

      gl.useProgram(program);
    }
    function initBuffer(){
      boxVertices =	[ // X, Y, Z           R, G, B
    		// Top
    		-1.0, 1.0, -1.0,   0.5, 0.5, 0.5,
    		-1.0, 1.0, 1.0,    0.5, 0.5, 0.5,
    		1.0, 1.0, 1.0,     0.5, 0.5, 0.5,
    		1.0, 1.0, -1.0,    0.5, 0.5, 0.5,

    		// Left
    		-1.0, 1.0, 1.0,    0.75, 0.25, 0.5,
    		-1.0, -1.0, 1.0,   0.75, 0.25, 0.5,
    		-1.0, -1.0, -1.0,  0.75, 0.25, 0.5,
    		-1.0, 1.0, -1.0,   0.75, 0.25, 0.5,

    		// Right
    		1.0, 1.0, 1.0,    0.25, 0.25, 0.75,
    		1.0, -1.0, 1.0,   0.25, 0.25, 0.75,
    		1.0, -1.0, -1.0,  0.25, 0.25, 0.75,
    		1.0, 1.0, -1.0,   0.25, 0.25, 0.75,

    		// Front
    		1.0, 1.0, 1.0,    1.0, 0.0, 0.15,
    		1.0, -1.0, 1.0,    1.0, 0.0, 0.15,
    		-1.0, -1.0, 1.0,    1.0, 0.0, 0.15,
    		-1.0, 1.0, 1.0,    1.0, 0.0, 0.15,

    		// Back
    		1.0, 1.0, -1.0,    0.0, 1.0, 0.15,
    		1.0, -1.0, -1.0,    0.0, 1.0, 0.15,
    		-1.0, -1.0, -1.0,    0.0, 1.0, 0.15,
    		-1.0, 1.0, -1.0,    0.0, 1.0, 0.15,

    		// Bottom
    		-1.0, -1.0, -1.0,   0.5, 0.5, 1.0,
    		-1.0, -1.0, 1.0,    0.5, 0.5, 1.0,
    		1.0, -1.0, 1.0,     0.5, 0.5, 1.0,
    		1.0, -1.0, -1.0,    0.5, 0.5, 1.0,
    	];
    	boxIndices = [
    		// Top
    		0, 1, 2,
    		0, 2, 3,

    		// Left
    		5, 4, 6,
    		6, 4, 7,

    		// Right
    		8, 9, 10,
    		8, 10, 11,

    		// Front
    		13, 12, 14,
    		15, 14, 12,

    		// Back
    		16, 17, 18,
    		16, 18, 19,

    		// Bottom
    		21, 20, 22,
    		22, 20, 23
    	];


    	let boxVertexBufferObject = gl.createBuffer();
    	gl.bindBuffer(gl.ARRAY_BUFFER, boxVertexBufferObject);
    	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(boxVertices), gl.STATIC_DRAW);

    	let boxIndexBufferObject = gl.createBuffer();
    	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, boxIndexBufferObject);
    	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(boxIndices), gl.STATIC_DRAW);
    }
    function initAttrib(){
    	let positionAttribLocation = gl.getAttribLocation(program, 'vertPosition');
    	gl.vertexAttribPointer(
    		positionAttribLocation, // Attribute location
    		3, // Number of elements per attribute
    		gl.FLOAT, // Type of elements
    		gl.FALSE,
    		6 * Float32Array.BYTES_PER_ELEMENT, // Size of an individual vertex
    		0 // Offset from the beginning of a single vertex to this attribute
    	);

    	gl.enableVertexAttribArray(positionAttribLocation);
    }
    function initUniform(){
      matWorldUniformLocation = gl.getUniformLocation(program, 'mWorld');
      matViewUniformLocation = gl.getUniformLocation(program, 'mView');
      matProjUniformLocation = gl.getUniformLocation(program, 'mProj');

      worldMatrix = new Float32Array(16);
      viewMatrix = new Float32Array(16);
      projMatrix = new Float32Array(16);
      mat4.identity(worldMatrix);
      mat4.lookAt(viewMatrix, [0, 0, -8], [0, 0, 0], [0, 1, 0]);
      mat4.perspective(projMatrix, glMatrix.toRadian(45), canvas.width / canvas.height, 0.1, 1000.0);

      gl.uniformMatrix4fv(matWorldUniformLocation, gl.FALSE, worldMatrix);
      gl.uniformMatrix4fv(matViewUniformLocation, gl.FALSE, viewMatrix);
      gl.uniformMatrix4fv(matProjUniformLocation, gl.FALSE, projMatrix);

      xRotationMatrix = new Float32Array(16);
      yRotationMatrix = new Float32Array(16);
    }

    function render(){
      identityMatrix = new Float32Array(16);
    	mat4.identity(identityMatrix);
    	angle = 0;

      requestAnimationFrame(renderLoop);
    }

    function renderLoop(){
      //console.log("loop trigered");

  		angle = performance.now() / 1000 / 6 * 2 * Math.PI;
  		mat4.rotate(yRotationMatrix, identityMatrix, angle, [0, 1, 0]);
  		mat4.rotate(xRotationMatrix, identityMatrix, angle / 4, [1, 0, 0]);
  		mat4.mul(worldMatrix, yRotationMatrix, xRotationMatrix);
  		gl.uniformMatrix4fv(matWorldUniformLocation, gl.FALSE, worldMatrix);

  		//gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
  		gl.drawElements(gl.TRIANGLES, boxIndices.length, gl.UNSIGNED_SHORT, 0);

      requestAnimationFrame(renderLoop);
    }
  </script>
</body>

</html>
